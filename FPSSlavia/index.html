<html>
	<head>
		<meta charset="utf-8">
		<title>FPS Slavia</title>
		<style>
			html, body {
				width: 100%;
				height: 100%;
			}

			body {
				background-color: #ffffff;
				margin: 0;
				overflow: hidden;
				font-family: arial;
			}
			
			
			#blocker {

				position: absolute;

				width: 100%;
				height: 100%;

				

			}
			
			

			#instructions {

				width: 100%;
				height: 100%;

				display: -webkit-box;
				display: -moz-box;
				display: box;

				-webkit-box-orient: horizontal;
				-moz-box-orient: horizontal;
				box-orient: horizontal;
                
				
				
				-webkit-box-pack: center;
				-moz-box-pack: center;
				box-pack: center;

				-webkit-box-align: center;
				-moz-box-align: center;
				box-align: center;

				color: #ffffff;
				text-align: center;

			}
			
            

		</style>
	</head>
	<body id='body' >
	    
		<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r77/three.min.js"></script>
		
		
		<script src="PointerLockControls.js"></script>
        <script src="https://code.createjs.com/soundjs-0.6.2.min.js"></script></head>
        
		
		<div id="blocker">

			<div id="instructions">
			
				
			</div>

		</div>
		</div>
		
		<div id="HUD" style="position:absolute;">
		
		
		
		</div>

		<script>
		    
			var pitchObject;
			var ep = false;
		    var IsHitting = false;
			var ecooldown = false;
			var tookGun = false;
			
			var WingDistance = 100;
		  
		     
            
			var cleared = false;
			
			
			
			
			function getDistance(mesh1, mesh2) {
            var dx = mesh1.position.x - mesh2.position.x;
            var dy = mesh1.position.y - mesh2.position.y;
            var dz = mesh1.position.z - mesh2.position.z;
			
            distance = Math.sqrt(dx*dx+dy*dy+dz*dz);
			//console.log(distance);
			
           }
			
				
         
			var camera, scene, renderer;
			var geometry, material, mesh;
			var controls;
			var map;
			var opend = false;
			var Ekey = false;
			var objects = [];
            var HitO;
			var distance;
		    var arrow;
			
			var Light;
			var Disco;
			
			
			var loaded = false;
			
			var hp = 100;

			var objects = [];
			
		

			var blocker = document.getElementById( 'blocker' );
			var instructions = document.getElementById( 'instructions' );

			// http://www.html5rocks.com/en/tutorials/pointerlock/intro/

			var havePointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;

			if ( havePointerLock ) {

				var element = document.body;

				var pointerlockchange = function ( event ) {

					if ( document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element ) {

						if (loaded == true){
						controlsEnabled = true;
						controls.enabled = true;

						blocker.style.display = 'none';
						}

					} else {

						controls.enabled = false;

						blocker.style.display = '-webkit-box';
						blocker.style.display = '-moz-box';
						blocker.style.display = 'box';

						instructions.style.display = '';

					}

				};

				var pointerlockerror = function ( event ) {

					instructions.style.display = '';

				};

				// Hook pointer lock state change events
				document.addEventListener( 'pointerlockchange', pointerlockchange, false );
				document.addEventListener( 'mozpointerlockchange', pointerlockchange, false );
				document.addEventListener( 'webkitpointerlockchange', pointerlockchange, false );

				document.addEventListener( 'pointerlockerror', pointerlockerror, false );
				document.addEventListener( 'mozpointerlockerror', pointerlockerror, false );
				document.addEventListener( 'webkitpointerlockerror', pointerlockerror, false );

				instructions.addEventListener( 'click', function ( event ) {

					instructions.style.display = 'none';

					// Ask the browser to lock the pointer
					element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;

					if ( /Firefox/i.test( navigator.userAgent ) ) {

						var fullscreenchange = function ( event ) {

							if ( document.fullscreenElement === element || document.mozFullscreenElement === element || document.mozFullScreenElement === element ) {

								document.removeEventListener( 'fullscreenchange', fullscreenchange );
								document.removeEventListener( 'mozfullscreenchange', fullscreenchange );

								element.requestPointerLock();
							}

						};

						document.addEventListener( 'fullscreenchange', fullscreenchange, false );
						document.addEventListener( 'mozfullscreenchange', fullscreenchange, false );

						element.requestFullscreen = element.requestFullscreen || element.mozRequestFullscreen || element.mozRequestFullScreen || element.webkitRequestFullscreen;

						element.requestFullscreen();

					} else {

						element.requestPointerLock();

					}

				}, false );

			} else {

				instructions.innerHTML = 'Your browser doesn\'t seem to support Pointer Lock API';

			}

			init();
			animate();
			
			var InAir = false;

			var controlsEnabled = false;

			var moveForward = false;
			var moveBackward = false;
			var moveLeft = false;
			var moveRight = false;
			var Sprint = false;
			var canJump = false;
			

			var prevTime = performance.now();
			var velocity = new THREE.Vector3();

			function init() {

				camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 100000 );


				scene = new THREE.Scene();
				
				//scene.fog = new THREE.Fog( 0xffffff, 4000, 4000 );

				//var light = new THREE.HemisphereLight( 0xeeeeff, 0x777788, 0.75 );
				//light.position.set( 0.5, 1, 0.75 );
				//scene.add( light );

				controls = new THREE.PointerLockControls( camera );
				scene.add( controls.getObject() );

				var onKeyDown = function ( event ) {

					switch ( event.keyCode ) {

						case 90: // Z
						case 87: // W
							moveForward = true;
							break;
						case 81: // Q
						case 65: // A
							moveLeft = true; break;

						case 83: // S
						 moveBackward = true;
							break;

						case 68: // D
							moveRight = true;
							break;
							
						case 69: // E
						    if (ecooldown == false){
							Ekey = true;
							}
							break;
							
						
						case 16: // SHIFT
							Sprint = true;
							break;

						case 32: // SPACE
							if ( canJump === true ){
							
                           	canJump = false;						
							velocity.y += 350;
							}
							
							
							break;

					}

				};

				var onKeyUp = function ( event ) {

					switch( event.keyCode ) {

						case 90: // Z
						case 87: // W
							moveForward = false;
							break;

						case 81: // Q
						case 65: // A
							moveLeft = false;
							break;

						case 83: // S
							moveBackward = false;
							break;

						case 68: // D
							moveRight = false;
							break;
						
						case 69: // E
							Ekey = false;
							ecooldown = true;
							setTimeout(function(){ ecooldown = false; }, 1000);
							break;
							
							case 16: // shift
							Sprint = false;
							break;

					}

				}; 
				
				
				document.addEventListener( 'keydown', onKeyDown, false );
				document.addEventListener( 'keyup', onKeyUp, false );

				
				// floor

				
				// objects
				
				
               
				
				
				    
				renderer = new THREE.WebGLRenderer({ antialias: true });
				renderer.setClearColor( 0xffffff );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );
				

				
				
				var loader = new THREE.ObjectLoader();
                 loader.load("scene.json",function ( obj ) {
				 loaded = true;
				
				 map = obj;
			     controls.getObject().position.set( 0, 50, 0);
				  
                 scene.add( map );
				 objects.push(map);
                 });

				window.addEventListener( 'resize', onWindowResize, false );
                
				loaded = true;
			}
                
				
				
			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}
			
			
			function TestandPrevCol(player, mesh, x,y,z ){
			
			
			
			
			if (player.position.z < mesh.position.z + z / 2 + 1 && player.position.z > mesh.position.z - z/2 - 1  
			 && player.position.x < mesh.position.x + x / 2 + 1 && player.position.x > mesh.position.x - x/2 - 1
			 && player.position.y < mesh.position.y + 100 + y / 2  && player.position.y > mesh.position.y - y/2 - 1){
			
			if( player.position.z > mesh.position.z + z/2 - 5 && player.position.y < mesh.position.y + y/2 + 1 ){ player.position.z = mesh.position.z + z/2; player.position.z = player.position.z + 2;  }
			else if( player.position.z < mesh.position.z - z/2 + 5 && player.position.y < mesh.position.y + y/2 + 1 ){ player.position.z = mesh.position.z - z/2; player.position.z = player.position.z - 2;  }
			
			if( player.position.x > mesh.position.x + x/2 - 5 && player.position.y < mesh.position.y + y/2 + 1 ){ player.position.x = mesh.position.x + x/2; player.position.x = player.position.x + 2;  }
		    else if( player.position.x < mesh.position.x - x/2 + 5 && player.position.y < mesh.position.y + y/2 + 1 ){ player.position.x = mesh.position.x - x/2; player.position.x = player.position.x - 2;  }
			
			if(player.position.y > mesh.position.y + y/2 && player.position.y < mesh.position.y + y/2 + 50){ player.position.y = mesh.position.y + y/2 + 50; velocity.y = 0; InAir = false;  canJump = true }
			else if(player.position.y > mesh.position.y - y/2 && player.position.y < mesh.position.y ){ velocity.y = 0; player.position.y = player.position.y - 1}
			
			
			}
			else{
			InAir = true;
			}	
			
			}
			
			
			var seeoutline = true;
			
			
			materialB = new THREE.MeshPhongMaterial( { specular: 0xffffff, shading: THREE.FlatShading} );
			
			///////////////////////////////////SPAWN/////////////////////////////////////////////////////////////////////////////
            //          altijd NEW                  geometry = vorm                   material = hoe eruitziet
			var BOXC = new THREE.Mesh( new THREE.BoxGeometry( 60, 100, 15), materialB );
			// geeft een plek / positie
			BOXC.position.set( 67.5, 50, 105);
			// voegt toe op plek (SCENE = WERELD)
			scene.add( BOXC );
			// of het zichtbaar is (var hierboven)
			BOXC.visible = seeoutline;
			
            //          altijd NEW                  geometry = vorm                   material = hoe eruitziet
		    var BOXC2 = new THREE.Mesh( new THREE.BoxGeometry( 60, 100, 15), materialB );
			// geeft een plek / positie
			BOXC2.position.set( 67.5, 50, -105);
			// voegt toe op plek (SCENE = WERELD)
			scene.add( BOXC2 );
			// of het zichtbaar is (var hierboven)
			BOXC2.visible = seeoutline;
			
			var BOXC3 = new THREE.Mesh( new THREE.BoxGeometry( 75, 100, 15), materialB );
			BOXC3.position.set( -67.5, 50, -105);
			scene.add( BOXC3 );
			BOXC3.visible = seeoutline;
			
			var BOXC4 = new THREE.Mesh( new THREE.BoxGeometry( 60, 100, 15), materialB );
			BOXC4.position.set( -67.5, 50, 105);
			scene.add( BOXC4 );
			BOXC4.visible = seeoutline;
			
			var BOXC5 = new THREE.Mesh( new THREE.BoxGeometry( 15, 100, 75), materialB );
			BOXC5.position.set( -105, 50, 75);
			scene.add( BOXC5 );
			BOXC5.visible = seeoutline;
			
			var BOXC6 = new THREE.Mesh( new THREE.BoxGeometry( 15, 100, 75), materialB );
			BOXC6.position.set( -105, 50, -75);
			scene.add( BOXC6 );
			BOXC6.visible = seeoutline;
			
			var BOXC7 = new THREE.Mesh( new THREE.BoxGeometry( 15, 100, 75), materialB );
			BOXC7.position.set( 105, 50, -75);
			scene.add( BOXC7 );
			BOXC7.visible = seeoutline;
			
			var BOXC8 = new THREE.Mesh( new THREE.BoxGeometry( 15, 100, 75), materialB );
			BOXC8.position.set( 105, 50, 75);
			scene.add( BOXC8 );
			BOXC8.visible = seeoutline;
			
			var BOXC9 = new THREE.Mesh( new THREE.BoxGeometry( 225, 20, 225), materialB );
			BOXC9.position.set( 0, 130, 0);
			scene.add( BOXC9 );
			BOXC9.visible = seeoutline;
			////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			
			/////////////////////////OutsideWalls/////////////////////////////////////////////////////////////////////////
			var OWall1 = new THREE.Mesh( new THREE.BoxGeometry( 8000, 300, 15), materialB );
			OWall1.position.set( 0, 150, -4000);
			scene.add( OWall1 );
			OWall1.visible = seeoutline;
			
			var OWall2 = new THREE.Mesh( new THREE.BoxGeometry( 15, 300, 8000), materialB );
			OWall2.position.set( -4000, 150, 0);
			scene.add( OWall2 );
			OWall2.visible = seeoutline;
			
			var OWall3 = new THREE.Mesh( new THREE.BoxGeometry( 8000, 300, 15), materialB );
			OWall3.position.set( 0, 150, 4000);
			scene.add( OWall3 );
			OWall3.visible = seeoutline;
			
			var OWall4 = new THREE.Mesh( new THREE.BoxGeometry( 15, 300, 8000), materialB );
			OWall4.position.set( 4000, 150, 0);
			scene.add( OWall4 );
			OWall4.visible = seeoutline;
			/////////////////////////////////////////////////////////////////////////////////////////////////////
			
			//////////////////////////////INNER1////////////////////////////////////////////////////
			var Inner1Wall1 = new THREE.Mesh( new THREE.BoxGeometry( 15, 220, 1690), materialB );
			Inner1Wall1.position.set( 925, 110, 75);
			scene.add( Inner1Wall1 );
			Inner1Wall1.visible = seeoutline;
			
			var Inner1Wall2 = new THREE.Mesh( new THREE.BoxGeometry( 15, 220, 1690), materialB );
			Inner1Wall2.position.set( -925, 110, -75);
			scene.add( Inner1Wall2 );
			Inner1Wall2.visible = seeoutline;
			
			var Inner1Wall3 = new THREE.Mesh( new THREE.BoxGeometry( 1690, 220, 15), materialB );
			Inner1Wall3.position.set( -75, 110, 925);
			scene.add( Inner1Wall3 );
			Inner1Wall3.visible = seeoutline;
			
			var Inner1Wall4 = new THREE.Mesh( new THREE.BoxGeometry( 1690, 220, 15), materialB );
			Inner1Wall4.position.set( 75, 110, -925);
			scene.add( Inner1Wall4 );
			Inner1Wall4.visible = seeoutline;
			
			//////////////////////////////////////////////////////////////////////////////////////////////
			
			//////////////////////INNER2//////////////////////////////////////////////////////////////////
			var Inner2Wall1 = new THREE.Mesh( new THREE.BoxGeometry( 15, 220, 700), materialB );
			Inner2Wall1.position.set( 925, 110, 1270);
			scene.add( Inner2Wall1 );
			Inner2Wall1.visible = seeoutline;
			
			var Inner2Wall2 = new THREE.Mesh( new THREE.BoxGeometry( 15, 220, 700), materialB );
			Inner2Wall2.position.set( -920, 110, 1270);
			scene.add( Inner2Wall2 );
			Inner2Wall2.visible = seeoutline;
			
			var Inner2Wall3 = new THREE.Mesh( new THREE.BoxGeometry( 15, 220, 700), materialB );
			Inner2Wall3.position.set( 925, 110, -1270);
			scene.add( Inner2Wall3 );
			Inner2Wall3.visible = seeoutline;
			
			var Inner2Wall4 = new THREE.Mesh( new THREE.BoxGeometry( 15, 220, 700), materialB );
			Inner2Wall4.position.set( -920, 110, -1270);
			scene.add( Inner2Wall4 );
			Inner2Wall4.visible = seeoutline;
			
			var Inner2Wall5 = new THREE.Mesh( new THREE.BoxGeometry( 700, 220, 15), materialB );
			Inner2Wall5.position.set( -1270, 110, 925);
			scene.add( Inner2Wall5 );
			Inner2Wall5.visible = seeoutline;
			
			var Inner2Wall6 = new THREE.Mesh( new THREE.BoxGeometry( 700, 220, 15), materialB );
			Inner2Wall6.position.set( 1270, 110, 925);
			scene.add( Inner2Wall6 );
			Inner2Wall6.visible = seeoutline;
			
			var Inner2Wall7 = new THREE.Mesh( new THREE.BoxGeometry( 700, 220, 15), materialB );
			Inner2Wall7.position.set( 1270, 110, -925);
			scene.add( Inner2Wall7 );
			Inner2Wall7.visible = seeoutline;
			
			var Inner2Wall8 = new THREE.Mesh( new THREE.BoxGeometry( 700, 220, 15), materialB );
			Inner2Wall8.position.set( -1270, 110, -925);
			scene.add( Inner2Wall8 );
			Inner2Wall8.visible = seeoutline;
			
			var Inner2Wall9 = new THREE.Mesh( new THREE.BoxGeometry( 1690, 220, 15), materialB );
			Inner2Wall9.position.set( 72.5, 110, 1612.5);
			scene.add( Inner2Wall9 );
			Inner2Wall9.visible = seeoutline;
			
			var Inner2Wall10 = new THREE.Mesh( new THREE.BoxGeometry( 1690, 220, 15), materialB );
			Inner2Wall10.position.set( -72.5, 110, -1612.5);
			scene.add( Inner2Wall10 );
			Inner2Wall10.visible = seeoutline;
			
			var Inner2Wall11 = new THREE.Mesh( new THREE.BoxGeometry( 15, 220, 1690), materialB );
			Inner2Wall11.position.set( -1612.5, 110, 72.5);
			scene.add( Inner2Wall11 );
			Inner2Wall11.visible = seeoutline;
			
			var Inner2Wall12 = new THREE.Mesh( new THREE.BoxGeometry( 15, 220, 1690), materialB );
			Inner2Wall12.position.set( 1612.5, 110, -72.5);
			scene.add( Inner2Wall12 );
			Inner2Wall12.visible = seeoutline;
			
			/////////////////////////////////////////////////////////////////////////////////////////////////
			
			
			
			
			
			
			
			
			var CollisionDetection = setInterval(function(){
			
			
			
		
		   
		    //dynamic collision
		   
			
			//////////////////////////////////SPAWN/////////////////////////////////////////
			//                PLAYER            OBJECT  AFMETINGEN VAN OBJECT
			TestandPrevCol(controls.getObject(), BOXC, 65, 100, 20);
			
			//                PLAYER            OBJECT  AFMETINGEN VAN OBJECT
			TestandPrevCol(controls.getObject(), BOXC2, 65, 100, 20);
			
			TestandPrevCol(controls.getObject(), BOXC3, 80, 100, 20);
			
			TestandPrevCol(controls.getObject(), BOXC4, 65, 100, 20);
			
			TestandPrevCol(controls.getObject(), BOXC5, 25, 100, 80);
			
			TestandPrevCol(controls.getObject(), BOXC6, 25, 100, 80);
			
			TestandPrevCol(controls.getObject(), BOXC7, 25, 100, 80);
			
			TestandPrevCol(controls.getObject(), BOXC8, 25, 100, 80);
			
			TestandPrevCol(controls.getObject(), BOXC9, 260, 80, 260);
			
			////////////////////////////////////////////////////////////////////////////////////////////
			///////////////////////////////////OutsideWall//////////////////////////////////////
			
			TestandPrevCol(controls.getObject(), OWall1, 8015, 300, 30);
			
			TestandPrevCol(controls.getObject(), OWall2, 30, 300, 8015);
			
			TestandPrevCol(controls.getObject(), OWall3, 8015, 300, 30);
			
			TestandPrevCol(controls.getObject(), OWall4, 30, 300, 8015);
			
		    ///////////////////////////////////////////////////////////////////////////////////////
			////////////////////////INNER1/////////////////////////////////////
			
			TestandPrevCol(controls.getObject(), Inner1Wall1, 30, 220, 1705);
			
			TestandPrevCol(controls.getObject(), Inner1Wall2, 30, 220, 1705);
			
			TestandPrevCol(controls.getObject(), Inner1Wall3, 1705, 220, 30);
			
			TestandPrevCol(controls.getObject(), Inner1Wall4, 1705, 220, 30);
			
			/////////////////////////////////////////////////////////////////////////////////////////
			////////////////////////INNER2//////////////////////////////////////////////////////////
			
			TestandPrevCol(controls.getObject(), Inner2Wall1, 30, 220, 715);
			
			TestandPrevCol(controls.getObject(), Inner2Wall2, 30, 220, 715);
			
			TestandPrevCol(controls.getObject(), Inner2Wall3, 30, 220, 715);
			
			TestandPrevCol(controls.getObject(), Inner2Wall4, 30, 220, 715);
			
			TestandPrevCol(controls.getObject(), Inner2Wall5, 715, 220, 30);
			
			TestandPrevCol(controls.getObject(), Inner2Wall6, 715, 220, 30);
			
			TestandPrevCol(controls.getObject(), Inner2Wall7, 715, 220, 30);
			
			TestandPrevCol(controls.getObject(), Inner2Wall8, 715, 220, 30);
			
			TestandPrevCol(controls.getObject(), Inner2Wall9, 1705, 220, 30);
			
			TestandPrevCol(controls.getObject(), Inner2Wall10, 1705, 220, 30);
			
			TestandPrevCol(controls.getObject(), Inner2Wall11, 30, 220, 1705);
			
			TestandPrevCol(controls.getObject(), Inner2Wall12, 30, 220, 1705);
			
			////////////////////////////////////////////////////////////////////////////////////////////
			
			
			}, 0.0025);
			           
                    
			var raycaster = new THREE.Raycaster();
			intersectionss = raycaster.intersectObjects( objects );
			
			var left = false;
            var up = true;
			
			
			
			// tijd van loop wordt niet gezegd, zoveel als pc aan kan
			function animate(){

				requestAnimationFrame( animate );
				
				//console.log(controls.getObject().position.y);
				
	
				if ( controlsEnabled ) {
				
					
					raycaster.set( camera.getWorldPosition(), camera.getWorldDirection() );
					
					var intersections = raycaster.intersectObjects( objects );
		       

					var isOnObject = intersections.length > 0;
					
					
					for ( var i = 0; i < intersections.length; i++ ) {

	             	//getDistance(intersections[ i ].object, controls.getObject());
					HitO = intersections[ i ].object;
					
	                }
					
					if ( intersections.length > 0 ){
					
					}else {
					HitO = false;
					}
					
				    
					

					var time = performance.now();
					var delta = ( time - prevTime ) / 1000;
					var speed = 4;
					
					if ( Sprint == true ){ 
					//SPEED
					speed = 7;
					}
					else{
					
					speed = 5;
					}

					velocity.x -= velocity.x * 10.0 * delta;
					velocity.z -= velocity.z * 10.0 * delta;

					
					
					if ( InAir == true ) {
					velocity.y -= 9.8 * 100.0 * delta; // 100.0 = mass
                    pup = false;
					}
					else{
					
					}
					
  
					if ( moveForward ) velocity.z -= 400.0 * delta * speed; 
					if ( moveBackward ) velocity.z += 400.0 * delta * speed;

					if ( moveLeft ) velocity.x -= 400.0 * delta * speed;
					if ( moveRight ) velocity.x += 400.0 * delta * speed;
					
                    
					if (velocity.y > 10){
					InAir = true;
					
					}
					
					
					
					
					
					controls.getObject().translateX( velocity.x * delta );
					controls.getObject().translateY( velocity.y * delta );
					controls.getObject().translateZ( velocity.z * delta );

					if ( controls.getObject().position.y < 50 || controls.getObject().position.y == 50 ) {

						velocity.y = 0;
						controls.getObject().position.y = 50;

						canJump = true;
						InAir = false;

					}
					
					
				

					prevTime = time;
					
					
					
                
				}
				
				

				renderer.render( scene, camera );
				
			}
		
		
		
	
            
		</script>
		<script src="Hud.js"></script>
        
        
	</body>
</html>
